---
title: DOM对象
date: 2023-04-27 14:39:13
permalink: /pages/d76dee/
---

# DOM 基础

## 什么是 DOM

- DOM( Document Object Model,文档对象模型)是 W3C 制订的一套技术规范,用来描述 Javascript 脚本如何与 HTML 进行交互的 Web 标准
- 加载 HTML 页面时, Web 浏览器生成一个树型结构,用来表示页面内部结构。DOM 将这种树型结构理解为由节点组成的 DOM 树
- DOM 规定了一系列标准接口,允许开发人员通过标准方式访问文档结构、操作网页内容、控制样式和行为等
- 在 DOM 中，接口可以理解为就是函数（函数 方法 API 接口 本质上都是一个函数）

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggpdz7u6ymj31iw0u0gqu.jpg)

## DOM 版本

- 在 W3C 推出 DOM 标准之前,市场上已经流行了不同版本的 DOM 规范,主要包括 IE 和 Netscape 两个浏览器厂商各自制订的私有规范,这些规范定义了一套文档结构操作的基本方法。虽然这些规范存在差异,但是思路和用法基本相同,如文档结构对象、事件处理方式、脚本化样式等。习惯上,我们把这些规范称为 DOM0 级,虽然这些规范没有统一并实现标准化,但是得到所有浏览器的支持并被广泛应用

- 1998 年 W3C 对 DOM 进行标准化,并先后推出了 3 个不同的版本,每个版本都是在上一个版本的基础上进行完善和扩展。但是在某些情况下,不同版本之间可能会存在不兼容的规定

  1. DOM1 级:1998 年 10 月,W3C 推出 DOM1.0 版本规范,作为推荐标准进行正式发布,主要包括两个子规范
     - DOM Core(核心部分):把 XML 文档设计为树形节点结构,并为这种结构的运行机制制订了套规范化标准,同时定义了创建、编辑、操纵这些文档结构的基本属性和方法
     - DOM HTML:针对 HTML 文档、标签集合,以及与个别 HTML 标签相关的元素定义了对象属性和方法
  2. DOM2 级:2000 年 11 月,W3C 正式发布了更新后的 DOM 核心部分,并在这次发布中添加了一些新规范,于是人们就把这次发布的 DOM 称为 2 级规范,2003 年 1 月,W3C 又正式发布了对 DOM HTML 子规范的修订,添加了针对 HTML4.01 和 XHTML1.0 版本文档中很多对象、属性和方法.W3C 把新修订的 DOM 规范统一称为 DOM2.0 推荐版本,该版本主要包括 6 个推荐子规范

     - DOM2core:继承于 DOM Core 子规范,规定了 DOM 文档结构模型,添加了更多的特性,如针对命名空间的方法等
     - DOM2HTML:继承于 DOM HTML,规定了针对 HTML 的 DOM 文档结构模型,并添加了一些属性
     - DOM2 Events:规定了与鼠标相关的事件(包括目标、捕获、冒泡和取消)的控制机制,但不含与键盘相关事件的处理部分
     - DOM2Style(或 DOM2Css):提供了访问和操纵所有与 Css 相关的样式及规则的能力
     - DOM2 Traversal 和 DOM2 Range:DoM2 Traversal 规范允许开发人员通过迭代方式访问 DOM
     - DOM2vews:提供了访问和更新文档表现(视图)的能力。

  3. DoM3 级:2004 年 4 月,W3C 发布了 DOM3 版本,DOMB3 版本主要包括以下 3 个推荐子规范
     - DOM3Core:继承于 DOM2Core,并添加了更多的新方法和属性,同时修改了已有的一些方法
     - DOM3 Load and Save:提供将 XML 文档的内容加载到 DOM 文档中,以及将 DOM 文档序列化为 XML 文档的能力
     - DOM3 Validation:提供了确保动态生成的文档的有效性的能力,即如何符合文档类型声明

## document 对象

- **Document 对象**是是 window 对象的一个属性，因此可以将 document 对象作为一个全局对象来访问。当浏览器载入 html 文档, 它就会成为 **Document 对象**。

- 打开控制台输入 document，然后我们就看到了一个 document 对象，既然是对象，输入 typeof document, 控制打印了 "object"

```js
console.log(document);
console.log(typeof document);
//查看document对象的方法和属性
for (var i in document) {
  console.log(i);
}
```

## 节点 进阶）

### 什么是节点

- 在网页中所有对象和内容都被称为节点。
- 如文档、元素、文本、属性、注释等。
- 节点(Node)是 DOM 最基本的单元,并派生出不同类型的节点,它们共同构成了文档的树形结构模型。

### 节点种类(常用)

- document 文档节点
- documentFragment 文档片段节点
- Element 元素节点
- attr 属性节点
- text 文本节点
- comment 注释节点

### 节点关系

DOM 把文档视为一棵树形结构,也称为节点树。节点之间的关系包括:上下父子关系，相邻兄弟关系

相邻兄弟关系

- 在节点树中,最顶端节点为根节点。
- 除了根节点之外,每个节点都有一个父节点
- 节点可以包含任何数量的子节点
- 叶子是没有子节点的节点
- 同级节点是拥有相同父节点的节点

### 节点类型名称和值

- childNodes:获取某个元素中的所有的子节点，使用中括号语法或者 item()方法可以获取对应的节点
- nodeType：获取节点的类型
- nodeName：节点名称
- nodeValue：节点的值

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>节点</title>
  </head>
  <body>
    <div id="box">
      <p>我是p标签</p>
      <span>hello</span>
      <i>i标签</i>
      <div>我是div</div>
      <!--<h3>h333</h3>-->
      <em>em标签</em>
    </div>
    <script>
      var oBox = document.getElementById("box");
      var nodes = oBox.childNodes;
      console.log(nodes); //节点的集合 NodeList类型
      console.log(nodes[3]); //直接可以获取到节点
      console.log(nodes.item(5)); //直接可以获取到节点

      //document的节点类型 名称 和值
      console.log(document.nodeType); //9
      console.log(document.nodeName); //#document
      console.log(document.nodeValue); //null

      //元素节点的类型 名称和 值
      console.log(nodes[1].nodeType); //1
      console.log(nodes[1].nodeName); //节点名称就是标签名 大写
      console.log(nodes[1].nodeValue); //null

      //文本节点的类型 名称和 值
      console.log(nodes[0].nodeType); //3
      console.log(nodes[0].nodeName); //#text
      console.log(nodes[0].nodeValue); //当前的文本内容

      //注释节点的类型 名称和 值
      console.log(nodes[9].nodeType); //8
      console.log(nodes[9].nodeName); //#comment
      console.log(nodes[9].nodeValue); //当前被注释的内容

      var myAttr = document.createAttribute("my");
      myAttr.value = "yes";
      console.log(myAttr);
      console.log(myAttr.nodeType); //2
      console.log(myAttr.nodeName); //my  属性节点是标准的键值对形式   属性名就是节点名称
      console.log(myAttr.nodeValue); //yes  属性值就是节点的值
    </script>
  </body>
</html>
```

## 访问节点

### 获取元素基础方法

- 通过标签名获取(完美兼容)

  - 可以使用内置对象 document 上的`getElementsByTagName`方法来获取页面上的某一种标签
  - 获取的一定是一个选择集（伪数组），不是数组，但是可以用下标的方式操作选择集里面的标签元素。

  - 这个集合拥有 length 属性

  - 通过标签名获取的对象 要么在使用的时候添加下标，要么在获取的时候添加下标,因为使用的时候，只能拿一个元素去使用

  ```js
  var oLis = document.getElemerntsByTagName("li");
  console.log(oLis);
  oLis[0].style.backgroundColor = "green";
  oLis[1].style.backgroundColor = "green";
  oLis[2].style.backgroundColor = "green";
  oLis[3].style.backgroundColor = "green";

  //或者

  var oLis1 = document.getElementsByTagName("li")[0];
  oLis1.style.backgroundColor = "pink";
  ```

- 通过 id 获取标签(完美兼容)

  - 可以使用内置对象 document 上的`getElementsByID`方法来获取页面上的某一种标签

  - id 是唯一的 所以通过 id 获取的标签也是唯一的

  - id 如果没有获取，那么仍然可以拿着 id 名来使用，因他是唯一的。但是不建议这样书写

  ```js
  var oBox = document.getElementById("box");
  console.log(oBox); //得到整个元素
  oBox.style.backgroundColor = "red";
  ```

- 通过类名来获取元素（不兼容 IE678）

  - 可以使用内置对象 document 上的`getElementsByClassName`方法来获取页面上的某一种标签

  - 使用和`getElementsByTagName`使用方法一致

  ```js
  // IE8不认识此方法：对象不支持“getElementsByClassName”属性或方法
  var oLi1 = document.getElementsByClassName("li1");
  oLi1[0].style.backgroundColor = "green";
  ```

- 通过 Name 属性获取元素（几乎不使用）

  - 可以使用内置对象 document 上的`getElementsByName`方法来获取页面上的某一种标签
  - 使用和`getElementsByTagName`使用方法一致
  - 兼容性：针对 ie：通过 Name 获取 只能获取到表单元素 不支持其他元素通过 name 属性获取

  ```js
  var oLi = document.getElementsByName("oli");
  oLi[0].style.height = "300px";
  ```

### selectors API

- selectors API 就是由 W3C 发布的一个事实标准，为浏览器实现元素的 css 选择器
- 两个核心方法 `querySelector`和`querySelectorAll（IE8+）`
- `querySelector`和`querySelectorAll`方法参数必须是符合 css 选择器语法规则的字符串。其中`querySelector`返回的是一个元素，`querySelectorAll`返回的是一个集合,一个 NodeList 对象（可以使用数组的 forEach 方法）

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>新的选择器</title>
  </head>
  <body>
    <ul class="outer">
      <li>11</li>
      <li>22</li>
      <li>33</li>
    </ul>
    <script>
      var oLis = document.querySelectorAll(".outer>li");
      console.log(oLis); //[li,li,li]
      console.log(oLis[0]);

      var oLi = document.querySelector(".outer>li");
      console.log(oLi);

      var oLi2 = document.querySelector(".outer>li:nth-child(2)");
      console.log(oLi2);
    </script>
  </body>
</html>
```

### selectors API 和传统方法的比较

- getElementsByXXXXX 获取的是一个动态的集合
- queryselectorAll 获取的是静态的集合
- 动态：选出来的元素会随着文档的改变而改变，静态：只要取出来，就和页面有没有任何关系

```js
var oUl = document.getElementsByTagName("ul")[0];
var oLis = oUl.getElementsByTagName("li");
console.log(oLis.length);

//直接陷入死循环  因为getElementsByTagName获取的元素是动态的，所以我们遍历的长度是获取元素的长度
// 每次插入一个 长度就会加1  所有永远运行不完
for (var i = 0; i < oLis.length; i++) {
  oUl.appendChild(document.createElement("li"));
}
console.log(oLis.length);

// querySelectorAll获取的元素就是静态的
var oLis = document.querySelectorAll("ul li");
console.log(oLis.length);

for (var i = 0; i < oLis.length; i++) {
  document.querySelector("ul").appendChild(document.createElement("li"));
}
console.log(oLis.length);
```

### 节点关系中访问节点方法

- parentNode 获取元素的父元素节点 (全兼容)

- children：获取元素的所有子元素节点(IE678 可以获取到注释节点 所有在 IE678 这样获取的时候注意不要写注释)

- 获取元素的上一个兄弟节点

  - previousSibling 获取元素的上一个兄弟节点（在 ie678 中获取的是上一个兄弟元素节点 在非 ie678 中获取的是上一个节点（可能是文本节点））

  - previousElementSibling 在 ie678 中不支持 在非 ie678 中获取的是上一个元素节点（兼容性有顺序要求 previousSibling 不能写前，因为 previousSibling 所有浏览器识别 但是意义不一样）

- 获取下一个兄弟节点

  - nextSibling 获取下一个兄弟节点

  - nextElementSibling 获取下一个兄弟节点

- 获取第一个子元素节点

  - firstChild:获取元素的第一个子元素节点

  - firstElementChild:获取元素的第一个子元素节点

- 获取最后一个子元素节点

  - lastChild:获取元素的最后一个子元素节点

  - lastElementChild:获取元素的最后一个子元素节点

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggpm1jky8wj30tp0fzaan.jpg)

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>访问元素节点</title>
  </head>
  <body>
    <ul id="box">
      <li>11</li>
      <li>22</li>
      <li>33</li>
      <li>44</li>
      <!--    <li>注释</li>-->
      <li>55</li>
    </ul>
    <div class="con">
      <div>1</div>
      <span>span</span>
      <p>p</p>
      <h2>h2</h2>
    </div>
    <script>
      //通过get选择器的方式选择
      var oBox = document.getElementById("box");
      var oLis = oBox.getElementsByTagName("li");
      console.log(oLis);

      /*var oCon = document.getElementsByClassName("con")[0];
    console.log(oCon.children);//  类数组集合 [div, span, p, h2]
    console.log(oBox.children);// 类数组集合  [li, li, li, li, li]*/

      //获取元素的父节点
      console.log(oLis[3]);
      console.log(oLis[3].parentNode);
      console.log(oLis[3].parentNode.parentNode);
      console.log(oLis[3].parentNode.parentNode.parentNode);
      console.log(oLis[3].parentNode.parentNode.parentNode.parentNode);
      console.log(
        oLis[3].parentNode.parentNode.parentNode.parentNode.parentNode
      ); //null
      // console.log(oLis[3].parentNode.parentNode.parentNode.parentNode.parentNode.parentNode);//报错

      //获取上一个兄弟节点
      console.log(oLis[3].previousSibling);
      console.log(oLis[3].previousElementSibling);
      // 兼容性写法
      if (oLis[3].previousElementSibling) {
        console.log(oLis[3].previousElementSibling);
      } else {
        console.log(oLis[3].previousSibling);
      }

      // 获取下一个兄弟
      console.log(oLis[3].nextElementSibling);

      //获取第一个子节点
      console.log(oBox.firstElementChild);

      //获取最后一个子节点
      console.log(oBox.lastElementChild);
    </script>
  </body>
</html>
```

### 其他获取节点方法

- 获取 body 元素

  `document.body`==`document.getElementsByTagName('body')[0]`

- 获取 head 元素

  `document.head`==`document.getElementsByTagName('head')[0]`

- 获取 html 元素

  `document.documentElement`==`document.getElementsByTagName('html')[0]`

# DOM 进阶

## 节点操作

- 因为节点关系都是只读的，所以 DOM 提供了一些操作节点的方法

### 创建节点

- 使用 document 对象的 createElement 方法能够根据参数指定的标签名创建一个新的元素。并返回对新元素的引用
- 使用 creatElement 方法创建的新元素不会被自动添加到文档里，需要使用 appendChild 等方法

### 创建文本节点

- 使用 document 对象的 createTextNode()方法可创建文本节点
- 参数是一个字符串
- 创建的文本节点需要使用 appendChild 等方法才能插入到元素节点中
- 当然也可以使用 innerHTML 方法给元素节点添加内容

### 插入节点

#### appendChild()

- appendChild()方法可以向当前节点的字节点列表的末尾添加新的节点
- 如果文档树中已经存在参数节点，则将从文档树中删除，然后重新插入新的位置

#### insertBefore()

- 使用 insertBefore(newChild,oldChild)方法可以在已有的子节点前插入一个新的子节点
- newChild 表示新插入的节点，oldChild 用于指定插入节点的后边的相邻位置。
- 插入成功以后，该方法返回新插入的节点
- insertBefore 可以把指定元素及其所包含的所有子节点都一起插入到指定位置中。同时会先删除移动的元素，再重新插入

### 复制节点

- cloneNode()方法可以创建一个节点的副本
- 参数 true (深复制)，复制整个节点和里面的内容 zs； false (浅复制)，只复制节点不要里面的内容
- 复制后的新节点，也不会被自动插入到文档，需要用到之前的方法去插入
- 由于复制的节点会包含原节点的所有特性，如果原节点中包含 id 属性，就会出现 id 属性值重叠的情况。为了避免潜在的冲突，应修改其中某个节点的 id 属性值

### 删除节点

- removeChild 方法可以从子节点列表中删除某个节点
- 如果删除成功，则返回被删除的节点，如果失败则返回 null
- 当 remove 删除节点的时候，该节点所包含的所有子节点将同时被删除

### 替换节点

- replaceChild(new,old)方法可以将某个子节点替换为另一个
- 替换节点替换的是所有子节点以及包含的所有内容
- 其中参数 new 为指定的新节点，old 代表被替换的节点
- 如果替换成功则返回被替换的节点，否则返回 null

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>节点的操作</title>
  </head>
  <body>
    <button id="btn1">按钮1</button>
    <button id="btn2">按钮2</button>
    <button id="btn3">按钮3</button>
    <button id="btn4">按钮4</button>
    <button id="btn5">按钮5</button>
    <button id="empty">清空</button>
    <ul id="box">
      <li>11</li>
      <li>22</li>
      <li my="hello">33</li>
      <li>44</li>
    </ul>

    <script>
      var oBox = document.getElementById("box");
      var oLis = oBox.getElementsByTagName("li");
      var oBtn1 = document.getElementById("btn1");
      var oBtn2 = document.getElementById("btn2");
      var oBtn3 = document.getElementById("btn3");
      var oBtn4 = document.getElementById("btn4");
      var oBtn5 = document.getElementById("btn5");
      var oEmpty = document.getElementById("empty");
      // 创建一个元素节点
      var newLi = document.createElement("li");
      console.log(newLi);

      //创建文本节点
      var newLiText = document.createTextNode("you 这谁呀 怎么这么帅");
      console.log(newLiText);

      //使用innerHTML给新节点传入内容
      newLi.innerHTML = "今天天气真好 <a herf='###' class='delete'>删除</a>";
      console.log(newLi);

      //给ul的尾部添加一个新的节点
      oBtn1.onclick = function () {
        // oBox.appendChild(newLiText);//插入文本节点
        newLi.appendChild(newLiText); //把文本节点插入新创建的li中
        oBox.appendChild(newLi); //直接插入元素节点

        var oDele = document.getElementsByClassName("delete")[0];
        console.log(oDele);
        oDele.onclick = function () {
          // console.log(oDele.parentNode.parentNode.removeChild(oDele.parentNode));;
          // remove(oDele.parentNode)
        };
      };

      //把已经存在的元素插入到某个元素的最后边
      oBtn2.onclick = function () {
        // oBox.appendChild(oLis[1]);
        console.log(oBox.appendChild(this)); //没有限制，只要获取到这个元素，就可以任意插入
      };

      //使用insertBefore插入节点
      oBtn3.onclick = function () {
        // console.log(oBox.insertBefore(newLi, oLis[1]));
        // console.log(oBox.insertBefore(oLis[3], oLis[1]));
        // prependChild(oBox,newLi)
        // insetAfter(newLi,oLis[1])
        // insetAfter(oLis[0],oLis[1])
        insetAfter(newLi, oLis[3]);
      };
      //克隆节点
      oBtn4.onclick = function () {
        console.log(oLis[2].cloneNode());
        console.log(oLis[2].cloneNode(true));
        console.log(oLis[2].cloneNode(false));
        /*var newClone = oLis[2].cloneNode(true);
        oBox.appendChild(newClone)*/
        oBox.appendChild(oLis[2].cloneNode(true));
      };
      //替换节点
      oBtn5.onclick = function () {
        console.log(oBox.replaceChild(newLi, oLis[2]));
        // console.log(document.documentElement.replaceChild(newLi, document.body));
      };

      oEmpty.onclick = function () {
        empty(oBox);
      };

      //在元素的最前边插入节点方法封装
      function prependChild(paren, ele) {
        if (paren.children.length) {
          paren.insertBefore(ele, paren.firstElementChild);
        } else {
          paren.appendChild(ele);
        }
        return ele;
      }
      //在某个节点的后边插入元素 方法封装
      function insetAfter(newele, oldele) {
        if (oldele.nextElementSibling) {
          oldele.parentNode.insertBefore(newele, oldele.nextElementSibling);
        } else {
          oldele.parentNode.appendChild(newele);
        }
        return newele;
      }

      //封装函数，传入元素，将该元素在结构中删除
      function remove(ele) {
        if (ele) {
          ele.parentNode.removeChild(ele);
          return ele;
        } else {
          return undefined;
        }
      }

      //封装函数 传入参数，清空所有子节点
      function empty(ele) {
        while (ele.firstElementChild) {
          ele.removeChild(ele.firstElementChild);
        }
      }
    </script>
  </body>
</html>
```

## 元素内容操作

### 读取和插入 HTML 字符串

- 使用元素的 innerHTML 属性可以返回调用元素所包含的所有子节点对应的 HTML 标记的字符串
- 使用 innerHTML 属性可以根据传入的 HTML 字符串创建新的 DOM 片段
- 然后这个 DOM 片段完全替换调用元素原有的所有子节点
- 设置好 innerHTML 之后，就可以像访问文档中其他节点一样访问新创建的节点
- 使用 documentElement 和 createTextNode 方法创建长的结构，代码会非常长，而 innerHTML 会执行的更快
- 大多数浏览器，不支持执行 innerHTML 插入的 script 标签

### 替换 HTML 字符串

- outerHTML 和 innerHTML 的功能相同，但是它会包含元素自身。

### 读写文本

- innerText 在指定的元素中插入文本，如果文本中包含 HTML 字符串，将被编码显示
- outerText 功能和 innerText 功能相似，但是它能覆盖原有的元素。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>元素内容的读取与写入</title>
  </head>
  <body>
    <button id="btn">按钮1</button>
    <button id="btn2">按钮2</button>
    <button id="btn3">按钮3</button>
    <ul id="box">
      <li>11</li>
      <li>22</li>
      <li>33</li>
      <li>44</li>
    </ul>
    <script>
      var oBtn = document.getElementById("btn");
      var oBtn2 = document.getElementById("btn2");
      var oBtn3 = document.getElementById("btn3");
      var oBox = document.getElementById("box");
      // 01.读取和插入html字符串--innerHTML
      oBtn.onclick = function () {
        // console.log(oBox.innerHTML);//把html也转成字符串输出

        // oBox.innerHTML = "<li>我是创建的li字符串 看我能不能被解析</li>"//替换原有所有内容

        var str = "<li>我是创建的li字符串 看我能不能被解析</li>";
        // oBox.appendChild(str);//appendChild插入字符串无效

        // oBox.innerHTML = oBox.innerHTML + str;

        oBox.innerHTML = str + oBox.innerHTML;
      };

      // 02.替换HTML字符串
      oBtn2.onclick = function () {
        // oBox.outerHTML = "<li>我是创建的li字符串 看我能不能被解析</li>";//包含box一起被替换了
        console.log(oBox.outerHTML); //包含box一起获取到了
      };

      oBtn3.onclick = function () {
        // oBox.innerText = "<li>我是创建的li字符串 看我能不能被解析</li>";
        // console.log(oBox.innerText);

        // console.log(oBox.outerText);
        oBox.outerText = "<li>我是创建的li字符串 看我能不能被解析</li>";
      };
    </script>
  </body>
</html>
```

### textContent

- textContent 属性设置或者返回指定节点的文本内容

  ```js
  document.getElementById("myList").textContent;
  document.getElementById("myList").textContent = "你好"；
  ```

- textContent 和 innerHTML 的区别

  - textContent 会获取 style= “display:none” 中的文本，而 innerText 不会

  - innerText 不会理会 html 格式，直接输出不换行的文本 ，textContent 会根据标签里面的元素独立一行

  - innerText 对 IE 的兼容性较好 ，textContent 虽然作为标准方法但是只支持 IE8+以上的浏览器

  - 兼容性处理

    ```js
    function setOrGetContent(node, content) {
      if (arguments.length === 1) {
        //代表当前是读取操作
        if (node.textContent) {
          //只要能拿到这个dom对象的textContent属性值，代表当前用户是高级浏览器
          return node.textContent;
        } else {
          //代表拿不到  那就是低级浏览器
          return node.innerText;
        }
      } else if (arguments.length === 2) {
        //代表写入操作
        if (node.textContent) {
          //代表高级
          node.textContent = content;
        } else {
          //代表低级
          node.innerText = content;
        }
      }
    }
    ```

## 属性节点

### 创建属性节点

- 使用 document 的 createAttribute 方法可以创建属性节点
- 使用属性节点的 name 属性，可以得到属性的名称
- 使用属性节点的 value 属性，可以设置和说去属性的值
- 创建的属性可以通过 setAttributeNode 来插入到元素中

### 读取属性值

- 在传统的 DOM 中国，常用点语法通过元素直接访问 HTML 属性，如 src、href 等
- 但是还有很多属性没有支持，需要用规范的写法获取
- 使用 getAttribute 方法 可以读取指定属性的值
- 对于 class 属性，必须使用 className 属性名，因为 class 是 JavaScript 语言的保留字
- 对于 for 属性，则必须使用 htmlFor 属性名
- 补充，在脚本化 css 中设置 float 属性和 text 属性，要改为 cssFloat 和 cssText（一次设置多个样式）使用

### 设置属性值

- 使用元素的 setAttribute(name,value)方法可以设置元素的属性值
- 参数 name 和 value 分别代表属性名称和属性值，并且必须是字符串
- 如果存在相同属性，则值被刷新，如果不存在则创建属性并添加

### 删除属性

- 使用元素的 removeAttribute()方法可以删除指定的属性
- 参数是要删除的属性名

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>属性的节点操作</title>
  </head>
  <body>
    <button id="btn1">按钮</button>
    <button id="btn2">按钮2</button>
    <ul id="box">
      <li>11</li>
      <li>22</li>
      <li>33</li>
      <li>44</li>
    </ul>
    <div id="con">
      <img src="./a.jpg" alt="我没有" your="html" class="link" />
      <a href="###">我是老A</a>
    </div>
    <script>
      var oCon = document.getElementById("con");
      var oBtn1 = document.getElementById("btn1");
      var oBtn2 = document.getElementById("btn2");
      oCons = oCon.children;

      // 1.创建属性节点
      var newAttr = document.createAttribute("my");
      console.log(newAttr.name); //获取属性节点的名
      console.log(newAttr.value); //获取属性节点的值
      newAttr.name = "your"; //name属性这样设置无效
      newAttr.value = "js"; //属性的值可以通过属性节点的value设置
      console.log(newAttr);

      //2.读取属性
      console.log(oCons[0].src);
      console.log(oCons[0].your); //不支持
      console.log(oCons[0].alt);
      console.log(oCons[1].href);

      console.log(oCons[0].class);

      console.log(oCons[0].getAttribute("your"));
      console.log(oCons[0].getAttribute("class"));

      //3.设置属性
      oBtn1.onclick = function () {
        oCons[0].alt = "我改变了";

        oCons[0].her = "hahah"; //对于自定义属性来说，这样的方法是把标签当成了js对象，给对象扩展的属性和方法

        //如果想要给元素设置自定义属性， 就需要使用setAttribute方法

        oCons[1].setAttribute("his", "jQuery");

        console.log(newAttr);

        oCons[0].setAttributeNode(newAttr);
      };

      oBtn2.onclick = function () {
        oCons[0].removeAttribute("your");
      };
    </script>
  </body>
</html>
```

## 自定义属性

- HTML5 允许用户为元素自定义属性，但是要求添加前缀 data-。
- 目的是为元素提供于渲染无关的附加信息，或者语义信息
- 可以使用 dataset 设置自定义属性名，不需要携带前缀
- 添加自定义属性后，可以通过元素的 dataset 属性访问自定义属性
- 删除自定义属性 可以使用 delete 方法

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>自定义属性</title>
  </head>
  <body>
    <button id="btn">按钮</button>
    <div id="box">
      <img src="./01.jpg" alt="图片" />
      <span data-name="span">我是span</span>
    </div>
    <script>
      var oBox = document.getElementById("box");
      var oBtn = document.getElementById("btn");
      var oBoxs = oBox.children;

      oBtn.onclick = function () {
        console.log(oBoxs[1].getAttribute("data-name"));

        console.log(oBoxs[1].dataset); //自身是包含当前元素所有 data- 前缀的属性的集合对象
        oBoxs[1].dataset.sex = "不知道";

        delete oBoxs[1].dataset.name;
      };
    </script>
  </body>
</html>
```

## 文档片段节点

- DocumentFragment 是一个虚拟的节点类型，仅仅存在于内存中，没有添加到文档树中，所以看不到渲染效果
- 使用文档碎片的好处，就是避免浏览器渲染和占用资源
- 当文档片段设计完善后，再使用 js 一次性添加到文档树中显示出来，提高效率，减少页面重绘的次数。解决大量添加节点时候的性能问题
- 使用 document.createDocumentFragment()方法创建，使用 appendChild 等方法插入

```html
<!DOCTYPE html>d
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>插入节点的性能优化</title>
  </head>
  <body>
    <ul id="box"></ul>
    <script>
      var oBox = document.getElementById("box");
      // 这种方法对DOM节点进行了100次的操作，非常耗费内存
      /*for (var i = 0; i < 100; i++) {
        var newLi = document.createElement("li");
        // textContent给元素插入文本
        newLi.textContent = "hello 6666";
        oBox.appendChild(newLi);
    }*/

      // createDocumentFragment创建一个DocumentFragment,它是一个轻量级的文档格式，作用是临时存储节点，等待插入到文档中
      // createDocumentFragment是解决大量添加节点时候的性能问题
      var fragment = document.createDocumentFragment();
      for (var i = 0; i < 100; i++) {
        var newLi = document.createElement("li");
        // textContent给元素插入文本
        newLi.textContent = "hello 6666";
        fragment.appendChild(newLi);
      }
      oBox.appendChild(fragment);
    </script>
  </body>
</html>
```

## 节点互换练习

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggufhzi1q0g30mr0dwtrt.gif)

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>节点互换练习</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        list-style: none;
      }
      #outer {
        width: 700px;
        margin: 50px auto;
        border: 1px solid #000;
        overflow: hidden;
      }
      #con1 {
        width: 300px;
        height: 400px;
        float: left;
        background-color: #4c71ff;
      }
      f #con2 {
        width: 300px;
        height: 400px;
        float: right;
        background-color: #4c71ff;
      }
      #controls {
        width: 100px;
        height: 400px;
        float: left;
        background-color: #2ba5eb;
        text-align: center;
      }
      #con1 .red,
      #con2 .red {
        background-color: red;
      }
    </style>
  </head>
  <body>
    <div id="outer">
      <ul id="con1">
        <li>我是con1的内容1</li>
        <li>我是con1的内容2</li>
        <li>我是con1的内容3</li>
        <li>我是con1的内容4</li>
      </ul>
      <div id="controls">
        <button id="right">>>>>>>></button>
        <button id="left"><<<<<<<</button>
      </div>
      <ul id="con2">
        <li>我是con2的内容1</li>
        <li>我是con2的内容2</li>
        <li>我是con2的内容3</li>
        <li>我是con2的内容4</li>
      </ul>
    </div>
    <script>
      var oCon1 = document.getElementById("con1");
      var oCon2 = document.getElementById("con2");
      var oRight = document.getElementById("right");
      var oLeft = document.getElementById("left");
      var oCon1Lis = oCon1.getElementsByTagName("li");
      var oCon2Lis = oCon2.getElementsByTagName("li");

      // 给所有的oCon1中的li绑定点击事件，点击以后颜色发生变化，并且被选中
      for (var i = 0; i < oCon1Lis.length; i++) {
        oCon1Lis[i].onclick = function () {
          this.className = "red";
          // 我们给选中的元素一个标记（设置自定义属性 change=true）
          this.setAttribute("change", "true");
        };
      }

      // 给oRight绑定点击事件 让选中的左边元素向右移动
      oRight.onclick = function () {
        //遍历所有的左边的li  判断哪一个被选中了
        for (var i = 0; i < oCon1Lis.length; i++) {
          // 判断哪一个li拥有change属性
          if (oCon1Lis[i].getAttribute("change")) {
            //移动过去的元素 需要把颜色 自定义属性全部还原
            oCon1Lis[i].className = "";
            oCon1Lis[i].removeAttribute("change");

            //把当前遍历的li给移动到oCon2中
            oCon2.appendChild(oCon1Lis[i]);
            // 因为移动过元素之后，后边的元素下标全部向上提一位，所以i要减1
            i--;
          }
        }
      };

      // 给所有的oCon2中的li绑定点击事件，点击以后颜色发生变化，并且被选中
      for (var i = 0; i < oCon2Lis.length; i++) {
        oCon2Lis[i].onclick = function () {
          this.className = "red";
          // 我们给选中的元素一个标记（设置自定义属性 change=true）
          this.setAttribute("change", "true");
        };
      }

      // 给oLeft绑定点击事件 让选中的右边元素向左移动
      oLeft.onclick = function () {
        //遍历所有的左边的li  判断哪一个被选中了
        for (var i = 0; i < oCon2Lis.length; i++) {
          // 判断哪一个li拥有change属性
          if (oCon2Lis[i].getAttribute("change")) {
            //移动过去的元素 需要把颜色 自定义属性全部还原
            oCon2Lis[i].className = "";
            oCon2Lis[i].removeAttribute("change");

            //把当前遍历的li给移动到oCon2中
            oCon1.appendChild(oCon2Lis[i]);
            // 因为移动过元素之后，后边的元素下标全部向上提一位，所以i要减1
            i--;
          }
        }
      };
    </script>
  </body>
</html>
```

# DOM 高级

## 事件模型

- 基本事件模型:也称为 DOM0 事件模型,是浏览器初期出现的一种比较简单的事件模型,主要通过 HTML 事件属性,为指定标签绑定事件处理函数。由于这种模型应用比较广泛,获得了所有浏览器的支持,目前依然比较流行。但是这种模型对于 HTML 文档标签依赖严重,不利于 JavaScript 独立开发
- DOM 事件模型:由 W3C 制订,是目前标准的事件处理模型。所有符合标准的浏览器都支持该模型,IE 怪异模式不支持。DOM 事件模型包括 DOM2 事件模块和 DOM3 事件模块,DOM3 事件模块为 DOM2 事件模块的升级版,略有完善,主要是新增了一些事情类型,以适应移动设备的开发需要,但大部分规范和用法保持一致。
- IE 事件模型:IE4.0 及其以上版本浏览器支持,与 DOM 事件模型相似,但用法不同
- Netscape 事件模型:由 Netscape4 浏览器实现,在 Netscape6 中停止支持

## 事件流

事件流就是多个节点对象对同一种事件进行响应的先后顺序,主要包括以下 3 种类型

- 冒泡型 事件从最特定的目标向最不特定的目标( document 对象)触发,也就是事件从下向上进行响应,这 个传递过程被形象地称为“冒泡”

- 捕获型 事件从最不确定的目标（document 对象）开始触发，然后到最特定的目标，也就是事件从上向下进行相应

- 混合型 w3C 的 DOM 事件模型支持捕获型和冒泡型两种事件流,其中捕获型事件流先发生,然后才发生冒泡型事件流。两种事件流会触及 DOM 中的所有层级对象,从 document 对象开始,最后返回 document 对象结束。因此,可以把事件传播的整个过程分为 3 个阶段

  - **捕获阶段**:事件从 document 对象沿着文档树向下传播到目标节点,如果目标节点的任何一个上级节点注册了相同的事件,那么事件在传播的过程中就会首先在最接近顶部的上级节点执行,依次向下传播
  - **目标阶段**:注册在目标节点上的事件被执行
  - **冒泡阶段**:事件从目标节点向上触发,如果上级节点注册了相同的事件,将会逐级响应,依次向上传播

  ![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggufn6gxdjj30v20jijuf.jpg)

## 绑定事件

- 静态绑定：把 JS 脚本作为属性值，直接赋值给事件属性
- 动态绑定：使用 DOM 对象的事件属性进行赋值
- 事件处理函数：事件处理函数是一类特殊的函数，与函数直接量结构相同，主要任务是实现事件处理，为异步调用，由事件触发进行相应。

### 绑定事件的事件机制（DOM0 事件）

使用 on+事件名这种方式注册的事件叫做 DOM0 级事件 所有浏览器都支持这种事件绑定

```js
var oOuter = my.getID("outer");
var oInner = my.getID("inner");
var oCon = my.getID("con");

//DOM 0级事件 在所有浏览器中都是冒泡的形式
oOuter.onclick = function () {
  alert("outer");
};
oInner.onclick = function () {
  alert("inner");
};
oCon.onclick = function () {
  alert("con");
};
```

```js
var oBox = document.getElementById("box");
/*使用DOM0级事件 对同一个元素绑定同一个事件 只能执行一次
        后边的绑定会把前边的绑定给覆盖掉*/
/*oBox.onclick = function () {
            alert(1);
        }
        oBox.onclick = function () {
            alert(2);
        }
        oBox.onclick = function () {
            alert(3);
        }
        oBox.onclick = function () {
            alert(4);
        }*/

oBox.onclick = function () {
  alert(4);
};
// 取消DOM 0 级事件  直接给事件一个null即可
document.onclick = function () {
  oBox.onclick = null;
};
```

### 注册事件

- 在 DOM 事件模型中，通过调用对象的 addEventListnenr()方法注册事件
  - type:注册事件的类型名,事件类型与事件属性不同,事件类型名没有 on 前缀,例如,对于事件属性 onclick 来说,所对应的事件类型为 click
  - listener:监听函数,即事件处理函数,在指定类型的事件发生时将调用该函数,在调用这个函数时,默认传递给它的唯一参数是 event 对象
  - useCapture:是一个布尔值,如果为 true,则指定的事件处理函数将在事件传播的捕获阶段触发，如果为 false,则事件处理函数将在冒泡阶段触发
- 使用 addEventListener()方法能够为多个对象注册相同的事件处理函数,也可以为同一个对象注册多件处理函数。为同一个对象注册多个事件处理函数对于模块化开发非常有用。
- IE 事件模型使用 attachEvent(etype,eventName)
  - type:事件类型：onclick、onkeyup 等
  - eventName：设置事件处理函数
  - 使用 attachEvent 注册事件时，其事件处理函数的调用对象不再是当前事件对象的本身，而是 window 对象，如果想要获取当前对象，则使用 event 事件对象

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>注册事件（事件监听）</title>
  </head>
  <body>
    <div id="demo">demo</div>
    <div id="outer">
      <div id="inner">
        <div id="con">k看我的事件流</div>
      </div>
    </div>
    <script>
      var oDemo = document.getElementById("demo");
      /*oDemo.addEventListener("click",function () {
        alert("demo1");
    },false);
    oDemo.addEventListener("click",function () {
        alert("demo2");
    },false);
    oDemo.addEventListener("click",function () {
        alert("demo3");
    },false);
    oDemo.addEventListener("click",function () {
        alert("demo4");
    },false);*/

      var oOuter = document.getElementById("outer");
      var oInner = document.getElementById("inner");
      var oCon = document.getElementById("con");
      /*oOuter.addEventListener("click",function () {
        alert("outer")
    },false)
    oInner.addEventListener("click",function () {
        alert("inner")
    },true)
    oCon.addEventListener("click",function () {
        alert("con")
    },true)*/

      // IE低版本事件监听
      /*oCon.attachEvent("onclick",function () {
        alert(1);
    })
    oInner.attachEvent("onclick",function () {
        alert(2);
    })*/
    </script>
  </body>
</html>
```

### 销毁事件

- 在 DOM 事件模型中，使用 removeEventListener()方法可以从指定对象中删除已经注册的事件处理函数
- removeEventListener()只能处理 addEventListener 方法注册的事件
- 当临时注册一个事件时，可以在处理完毕后删掉它，这样能够节省系统资源
- IE 事件模型使用 detachEvent 方法注销事件

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Title</title>
  </head>
  <body>
    <div id="box">点击我有惊喜哦</div>
    <button id="btn">取消惊喜</button>
    <script>
      var oBox = document.getElementById("box");
      var oBtn = document.getElementById("btn");

      /*oBox.onclick = function () {
        alert("圣诞快乐");
    }
    //点击btn 取消box的DOM0点击事件
    oBtn.onclick = function () {
        oBox.onclick = null;
    }*/

      // 必须保证绑定的函数和移除的函数是同一个函数
      /*function f(){
        alert("圣诞快乐")
    }
    oBox.addEventListener("click",f,false);
    //点击btn 取消box的DOM2点击事件
    oBtn.onclick = function () {
        oBox.removeEventListener("click",f)
    }*/

      function f() {
        alert("圣诞快乐");
      }
      oBox.attachEvent("onclick", f);

      oBtn.onclick = function () {
        oBox.detachEvent("onclick", f);
      };
    </script>
  </body>
</html>
```

### 绑定事件兼容

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>DOM2级事件的兼容</title>
  </head>
  <body>
    <button id="btn">移除事件</button>
    <div id="box">box</div>
    <script src="./my.js"></script>
    <script>
      var oBox = document.getElementById("box");
      var oBtn = document.getElementById("btn");
      function fn1() {
        alert("看我");
      }

      /*function addEvent(ele,type,fn,boo) {
        // DOM2级事件绑定兼容性封装
        if (ele.addEventListener){
            ele.addEventListener(type,fn,boo||false);
        }else if (ele.attachEventhEvent){
            ele.attachEvent("on"+type,fn)
        }else{
            ele["on"+type] = fn;
        }
    }*/
      my.addEvent(oBox, "click", fn1);

      /*function removeEvent(ele,type,fn){
        if (ele.removeEventListener){
            ele.removeEventListener(type,fn);
        }else if(ele.detachEvent){
            ele.detachEvent("on"+type,fn)
        }else{
            ele["on" + type] = null;
        }
    }*/

      oBtn.onclick = function () {
        my.removeEvent(oBox, "click", fn1);
      };
      /*// DOM2级事件绑定兼容性封装
    if (oBox.addEventListener){
        oBox.addEventListener("click",fn1,false);
    }else if (oBox.attachEvent){
        oBox.attachEvent("onclick",fn1)
    }else{
        oBox.onclick = fn1;
    }


    oBtn.onclick = function () {
        if (oBox.removeEventListener){
            oBox.removeEventListener("click",fn1);
        }else if(oBox.detachEvent){
            oBox.detachEvent("onclick",fn1)
        }else{
            oBox.onclick = null;
        }
    }*/
    </script>
  </body>
</html>
```

## DOMContentLoaded 事件

- window.onload 当所有的节点和资源加载完成才执行
- 加载需要等待资源加载 并且还只能对 window 绑定一次
- 解决方法 1： 仍然是等资源加载完成才执行
- 解决方法 2 使用 DOMContentLoaded 事件 ：当所有节点加载完毕就可以执行
- DOMContentLoaded 是 DOM2 级的事件 需要使用 DOM2 的监听方式来绑定事件

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>DOMContentLoaded</title>
    <script>
      // window.onload当所有的节点和资源加载完成才执行
      // 加载需要等待资源加载 并且还只能对window绑定一次
      /*window.onload = function () {
            var oBox = document.getElementById("box");
            oBox.onclick = function () {
                alert(1);
            }
        }*/

      //解决方法1： 仍然是等资源加载完成才执行
      /*window.addEventListener("load",function () {
            var oBox = document.getElementById("box");
            oBox.onclick = function () {
                alert(1);
            }
        })*/

      //解决方法2  使用DOMContentLoaded事件  ：当所有节点加载完毕就可以执行
      // onDOMContentLodeaded是DOM2级的事件  需要使用DOM2的监听方式来绑定事件
      window.addEventListener(
        "DOMContentLoaded",
        function () {
          var oBox = document.getElementById("box");
          oBox.onclick = function () {
            alert(1);
          };
        },
        false
      );
    </script>
  </head>
  <body>
    <div id="box">1111</div>
  </body>
</html>
```

## event 对象

- event 对象由事件自动创建,记录了当前事件的状态,如事件发生的源节点、键盘按键的响应状态、鼠标指针的移动位置、鼠标按键的响应状态等信息,
- event 对象的属性提供了有关事件的细节,其方法可以控制事件的传播
- 2 级 DOM Events 规范定义了一个标准的事件模型,它被除了 IE 低版本以外的所有现代浏览器所实现,而 IE 定义了专用的、不兼容的模型。简单比较两种事件模型如下：在 DOM 事件模型中, event 对象被传递给事件处理函数,但是在 IE 事件模型中,它被存储在 window 对象的 event 属性中
  > - bubbles：返回布尔值,指示事件是否是冒泡事件类型。如果事件是冒泡类型,则返回 tue:否则返回 fasle
  > - cancelable:返回布尔值,指示事件是否可以取消的默认动作,如果使用 preventDefault 方法可以取消与事件关联的默认动作则返回值为 mue:否则为 false
  > - target:返回事件的目标节点
  > - type:事件类型
  > - preventDefault():通知浏览器不要执行与事件关联的默认动作
  > - stopPropagation():阻止事件在捕获、目标、冒泡阶段的进一步传播

```js
var oBox = document.getElementById("box");
/*oBox.onclick = function () {
        console.log(window.event);
        // console.log(1);
    }
    oBox.onclick = function (e) {
        console.log(e);
        // console.log(1);
    }*/

// 兼容性获取event事件对象：
oBox.onclick = function (e) {
  var e = e || window.event;
  console.log(e);
};
```

## event 事件的鼠标定位

- clientX:以浏览器窗口左上顶角为原点,定位 x 轴坐标
- offsetX:以当前事件的目标对象左上顶角为原点,定位 x 轴坐标
- pageX:以 document 对象(即文档窗口)左上顶角为原点,定位 x 轴坐标(不兼容 IE)
- screenX:计算机屏幕左上顶角为原点,定位 x 轴坐标

```js
var oCon = document.getElementById("con");
oCon.onclick = function (e) {
  var e = e || window.event;
  // console.log(e.clientX,e.clientY);
  // console.log(e.offsetX,e.offsetY);
  // console.log(e.pageX,e.pageY);
  // console.log(e.screenX,e.screenY);

  console.log(getEventPage(e));
};

// pageX和pageY的封装
function getEventPage(e) {
  if (e.pageX) {
    return {
      x: e.pageX,
      y: e.pageY,
    };
  } else {
    return {
      x: document.body.scrollLeft + e.clientX,
      y: document.body.scrollTop + e.clientY,
    };
  }
}
```

## 阻止传播

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>阻止传播</title>
    <style>
      #outer {
        width: 100px;
        height: 100px;
        background-color: red;
      }
      #inner {
        width: 100px;
        height: 50px;
        background-color: yellow;
      }
      #box {
        width: 100px;
        height: 20px;
        background-color: pink;
      }
    </style>
  </head>
  <body>
    <div id="outer">
      <div id="inner">
        <div id="box">box</div>
        inner
      </div>
      outer
    </div>
    <script>
      var oOuter = document.getElementById("outer");
      var oInner = document.getElementById("inner");
      var oBox = document.getElementById("box");

      oOuter.addEventListener(
        "click",
        function (ev) {
          // ev.stopPropagation?ev.stopPropagation():ev.cancelBubble = true;
          alert(1);
        },
        true
      );
      oInner.addEventListener(
        "click",
        function () {
          alert(2);
        },
        true
      );
      oBox.addEventListener(
        "click",
        function (ev) {
          // 阻止传播
          // 现代浏览器中：
          /* ev.stopPropagation();

        // ie678浏览器中
        ev.cancelBubble = true;*/

          // ev.stopPropagation?ev.stopPropagation():ev.cancelBubble = true;
          alert(3);
        },
        true
      );
    </script>
  </body>
</html>
```

## 阻止默认事件

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>阻止默认事件</title>
  </head>
  <body>
    <a id="a1" href="http://www.baidu.com">百度一下你就知道</a>
    <script>
      var oA1 = document.getElementById("a1");
      oA1.onclick = function (ev) {
        var ev = ev || window.event;

        // 阻止默认事件
        /*在现代浏览器：
        ev.preventDefault();
        在IE678：
        ev.returnValue = false;*/

        /*if(ev.preventDefault){
            ev.preventDefault();
        }else{
            ev.returnValue = false;
        }*/

        // ev.preventDefault?ev.preventDefault():ev.returnValue = false;

        return false; //如果说用来阻止默认事件，必须写在函数的最下边  因为他下边的代码不再执行
      };
    </script>
  </body>
</html>
```

## 键盘事件

### 键盘事件

- 当用户操作键盘的时候会触发键盘事件
- keydown：键盘被按下某个按键的时候触发，如果按住某一个按键，会不断触发该事件
- keyup：释放某一个按键的时候触发。不是持续相应状态

```js
document.onkeydown = function (e) {
  var e = e || window.event;
  console.log(e);
};
```

### 键盘事件属性

- 键盘事件定义了很多属性
- keyCode：对应键盘中对应键位的键值
- shiftKey、ctrlKey、altKey 是否按下 shift strl alt 按键 返回布尔值

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>键码</title>
  </head>
  <body>
    Jintiantianqizhenhao
    <script>
      document.onkeydown = function (ev) {
        /*var ev = ev || window.event;
        // console.log(ev)
        if (ev.keyCode == 67 && ev.ctrlKey) {
            alert("你又来复制了？");
        }

        return false;*/
        console.log(1);
      };
    </script>
  </body>
</html>
```

### 键盘控制移动

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>键盘控制移动</title>
    <style>
      #box {
        width: 100px;
        height: 100px;
        background-color: red;
        position: absolute;
        left: 0;
        top: 0;
      }
    </style>
  </head>
  <body>
    <div id="box"></div>
    <script>
      var oBox = document.getElementById("box");
      /*document.onkeydown = function (ev) {
        // console.log(1);
        var ev = ev || window.event;
        if(ev.keyCode == 39){
            oBox.style.left = oBox.offsetLeft + 1 + 'px';
        }
        if(ev.keyCode == 38){
            oBox.style.top = oBox.offsetTop - 1 + 'px';
        }
        if(ev.keyCode == 37){
            oBox.style.left = oBox.offsetLeft - 1 + 'px';
        }
        if(ev.keyCode == 40){
            oBox.style.top = oBox.offsetTop + 1 + 'px';
        }
    }*/

      var shang = false,
        xia = false,
        zuo = false,
        you = false;
      var x = 0,
        y = 0;
      document.onkeydown = function (ev) {
        var ev = ev || window.event;
        /*if (ev.keyCode == 38){
            shang = true;
        }
        if (ev.keyCode == 39){
            you = true;
        }
        if (ev.keyCode == 40){
            xia = true;
        }
        if (ev.keyCode == 37){
            zuo = true;
        }*/

        switch (ev.keyCode) {
          case 38:
            shang = true;
            break;
          case 39:
            you = true;
            break;
          case 40:
            xia = true;
            break;
          case 37:
            zuo = true;
            break;
        }
      };
      document.onkeyup = function (ev) {
        var ev = ev || window.event;
        switch (ev.keyCode) {
          case 38:
            shang = false;
            break;
          case 39:
            you = false;
            break;
          case 40:
            xia = false;
            break;
          case 37:
            zuo = false;
            break;
        }
      };
      timer = setInterval(function () {
        if (shang) {
          y--;
        }
        if (xia) {
          y++;
        }
        if (zuo) {
          x--;
        }
        if (you) {
          x++;
        }

        oBox.style.top = y + "px";
        oBox.style.left = x + "px";
      }, 10);
    </script>
  </body>
</html>
```

### 敲回车提交表单

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>06.敲回车提交表单</title>
  </head>
  <body>
    <form id="form" action="http://www.baidu.com">
      请输入手机号
      <input type="text" id="ipt" />
    </form>
    <script>
      /*
        当用户输入完成敲击回车按键的时候。如果用户输入的都是11为纯数字  那么就让用户提交  否则不提交
     */
      var oForm = document.getElementById("form");
      var oIpt = document.getElementById("ipt");

      // 我们一般提交表单的时候，判断比较复杂 ，基本不会使用默认的跳转  而是我们主动跳转
      // 所以一般在提交事件中，首先阻止默认事件
      oIpt.onkeydown = function (ev) {
        var ev = ev || window.event;
        // ev.preventDefault?ev.preventDefault():ev.returnValue = false;

        if (ev.keyCode == 13) {
          if (this.value.length == 11 && !isNaN(this.value)) {
            alert("输入正确");
            // 手动让表单提交  可以让form调用submit方法
            oForm.submit();
          } else {
            alert("重新输入");
            // ev.preventDefault?ev.preventDefault():ev.returnValue = false;
            return false;
          }
        }
      };
    </script>
  </body>
</html>
```

## 事件委托

- 事件委托（delegate） 也称为事件托管或者事件代理，就是把目标节点的事件绑定到祖先的节点上
- 这种简单而优雅的事件注册方式是给予事件传播过程中，逐层冒泡总能被祖先元素捕捉到
- 优点：优化代码提升性能，把 html 和 js 分离，防止动态添加或删除节点中注册事件的丢失现象

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>事件委托</title>
  </head>
  <body>
    <button id="btn">添加一个新元素</button>
    <ul id="box">
      <li>11</li>
      <li>22</li>
      <li>33</li>
      <li>44</li>
      <li>55</li>
    </ul>
    <script>
      var oBtn = document.getElementById("btn");
      var oBox = document.getElementById("box");
      var oLis = oBox.getElementsByTagName("li");

      /*事件委托的优点：
        1、可以对未来的元素绑定事件
        2、避免使用for循环 提高效率*/
      // 事件委托的原理：冒泡
      oBox.onclick = function (ev) {
        var ev = ev || window.event;
        // ev.target当前时间精确发生的元素
        console.log(ev.target);

        // 在这里this仍然是指向oBox
        // this.style.backgroundColor = "red";

        // 给精确的元素绑定点击事件，但是没有判断   所有元素都能触发
        // ev.target.style.backgroundColor = "red";

        if (ev.target.nodeName.toLowerCase() == "li") {
          ev.target.style.backgroundColor = "red";
        }
      };

      oBtn.onclick = function () {
        var newLi = document.createElement("li");
        newLi.innerHTML = "newLi";
        oBox.appendChild(newLi);
      };
    </script>
  </body>
</html>
```

## 选择城市

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggwnex55wdg30n30dwaib.gif)

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>选择城市</title>
    <link rel="stylesheet" href="./reset.css" />
    <style>
      #outer {
        width: 400px;
        margin: 20px auto;
      }
      #con {
        position: relative;
      }
      #select {
        height: 40px;
        background-color: grey;
        line-height: 40px;
      }
      #cityList {
        overflow: hidden;
        width: 400px;
        position: absolute;
        background-color: red;
        display: none;
      }
      #cityList li {
        width: 80px;
        text-align: center;
        margin: 10px;
        float: left;
      }
    </style>
  </head>
  <body>
    <div id="outer">
      <h2 id="title">深圳</h2>
      <div id="con">
        <p id="select">点击我选择城市</p>
        <ul id="cityList">
          <li>深圳</li>
          <li>北京</li>
          <li>广州</li>
          <li>上海</li>
          <li>长沙</li>
          <li>南昌</li>
          <li>武汉</li>
          <li>焦作</li>
          <li>郑州</li>
          <li>太原</li>
          <li>草围</li>
        </ul>
      </div>
    </div>
    <script>
      var oCityList = document.getElementById("cityList");
      var oTitle = document.getElementById("title");
      document.onclick = function (ev) {
        var ev = ev || window.event;
        /*在现代浏览器中直接使用  ev.target
        在ie678中  使用 window.target.srcElement; */
        var target = ev.target || target.srcElement;
        if (target.id == "select") {
          oCityList.style.display = "block";
          return;
        }
        if (target.nodeName == "LI" && target.parentNode.id == "cityList") {
          oCityList.style.display = "none";
          oTitle.innerHTML = target.innerHTML;
          return;
        }
        oCityList.style.display = "none";
      };
    </script>
  </body>
</html>
```
